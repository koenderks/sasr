[["index.html", "Statistical Auditing with R, 1st Edition Welcome", " Statistical Auditing with R, 1st Edition Koen Derks 2022-12-15 Welcome Welcome to the book Statistical Audit Sampling with R, a practical guide for auditors that want to use state-of-the-art statistical methodology in the audit. This book focuses on audit sampling but approaches it from two viewpoints: the classical (frequentist) approach and the Bayesian approch. Through these two lenses, it explains the statistical theory underlying commonly applied audit sampling procedures, and demonstrates how to perform these procedures in a statistically sound manner compliant with international auditing standards using the jfa (Derks 2022) R package. Please keep in mind that this is a preview release and a number of chapters are still missing. If you are missing some of the content today, then check back tomorrow: This book is actively being worked on. References "],["preface.html", "Preface", " Preface This book is for auditors who want to employ statistical audit sampling in audit practice using the statistical programming language R. It thoroughly, but understandably, covers an array of state-of-the-art statistical instruments available to auditors, explaining what they are, the assumptions on which they are based, and when they should be used. Furthermore, it offers concrete suggestions for incorporating advanced statistical methods into audit practice and demonstrates their usefulness using real-life case studies. Hopefully, this book can be a resource for the efficient and effective use of statistical methods in audit practice. This book adresses the need for a transparent and clear description of the application of statistical sampling methodology in audit practice. I have found that most guidance about audit sampling contain insufficient detail to allow for transparent reproduction or understanding. Furthermore, the practical implementation of these methods is often untransparent and closed-source via commercial tools or excel sheets internally used by the audit firm. As such, auditors may try to understand the mechanisms at play but are often left with more questions that they arrived with. This book aims to give full control back to the auditor when it comes to explaining the statistical methodology used in practice. This book focuses on audit sampling but approaches it from two viewpoints: the classical (frequentist) approach and the Bayesian approch. Through these two lenses, it explains the statistical theory underlying commonly applied audit sampling procedures, and demonstrates how to perform these procedures in a statistically sound manner compliant with international auditing standards. It also makes the case for adopting Bayesian statistical methods in the audit practice. Bayesian inference can bring many practical advantages for the auditor and this book will discuss these in detail. In part 1, Chapter 1 provides an introduction to the R programming language. Chapter 2 gives a brief overview of how statistical methodology can be applied in the audit. In part 2, Chapter 3 discusses the basic statistical theory underlying audit sampling. Chapter 4 discusses the standard audit sampling workflow. Chapter 5, 6, 7, and 8 go into more detail about using statistial methods to plan, select and evaluate audit samples. Finally, Chapter 9 discusses other software implementations of audit sampling. In part 3, Chapter 10 gives an overview of the basic statistical theory underlying data auditing. "],["CHAPTER-R-BASICS.html", "Chapter 1 R Basics", " Chapter 1 R Basics This chapter covers the basics: installing and using packages and loading data. "],["installing-a-package.html", "1.1 Installing a Package", " 1.1 Installing a Package This book illustrates its concepts and ideas using the jfa package, which can be downloaded from CRAN. You can install this package by running the command below in R: install.packages(&quot;jfa&quot;) "],["loading-a-package.html", "1.2 Loading a Package", " 1.2 Loading a Package To load a package into your R session, call library() and provide the name of the package you want to load. Naturally, this requires that you already have the package installed on the computer. For example, before running the examples in this book, you can load the jfa package with: library(jfa) If you want a deeper understanding of how the jfa package works, or want to look at the source code of the package, see the package website. Packages in R are collections of functions and/or data that are bundled up for easy distribution, and installing a package will extend the functionality of R on your computer. If an R user creates a package and thinks that it might be useful for others, that user can distribute it through a package repository. The primary repository for distributing R packages is called CRAN (the Comprehensive R Archive Network), but there are others, such as Bioconductor, which specializes in packages related to genomic data. If you have spent much time learning R, you may have heard of the tidyverse, which is a collection of R packages that share common ideas of how data should be structured and manipulated. This is in contrast to base R, which is the set of packages that are included when you just download and install R. The tidyverse is a set of add-ons for R, which make it easier to do many operations related to data manipulation and visualization. This book mostly uses the tidyverse, as I believe that it provides a quicker and simpler (but not less powerful!) way to work with data. "],["upgrading-a-package.html", "1.3 Upgrading a Package", " 1.3 Upgrading a Package To update a package in your R library, call update.packages() and provide the name of the package you want to update. For example, you can update the jfa package with: update.packages(&quot;jfa&quot;) "],["loading-a-delimited-text-data-file.html", "1.4 Loading a Delimited Text Data File", " 1.4 Loading a Delimited Text Data File 1.4.1 Problem You want to load data from a delimited text file. 1.4.2 Solution The most common way to read in a file is to use comma-separated values (CSV) data: data &lt;- read.csv(&quot;datafile.csv&quot;) Alternatively, you can use the read_csv() function (note the underscore instead of period) from the readr package. This function is significantly faster than read.csv(), and 1.4.3 Discussion Since data files have many different formats, there are many options for loading them. For example, if the data file does not have headers in the first row: data &lt;- read.csv(&quot;datafile.csv&quot;, header = FALSE) The resulting data frame will have columns named V1, V2, and so on, and you will probably want to rename them manually: # Manually assign the header names names(data) &lt;- c(&quot;Column1&quot;, &quot;Column2&quot;, &quot;Column3&quot;) You can set the delimiter with sep. If it is space-delimited, use sep = \" \". If it is tab-delimited, use \\t, as in: data &lt;- read.csv(&quot;datafile.csv&quot;, sep = &quot;\\t&quot;) By default, strings in the data are treated as factors. Suppose this is your data file, and you read it in using read.csv(): &quot;First&quot;,&quot;Last&quot;,&quot;Sex&quot;,&quot;Number&quot; &quot;Currer&quot;,&quot;Bell&quot;,&quot;F&quot;,2 &quot;Dr.&quot;,&quot;Seuss&quot;,&quot;M&quot;,49 &quot;&quot;,&quot;Student&quot;,NA,21 The resulting data frame will store First and Last as factors, though it makes more sense in this case to treat them as strings (or character vectors in R terminology). To differentiate this, use stringsAsFactors = FALSE. If there are any columns that should be treated as factors, you can then convert them individually: data &lt;- read.csv(&quot;datafile.csv&quot;, stringsAsFactors = FALSE) # Convert to factor data$Sex &lt;- factor(data$Sex) str(data) #&gt; &#39;data.frame&#39;: 3 obs. of 4 variables: #&gt; $ First : chr &quot;Currer&quot; &quot;Dr.&quot; &quot;&quot; #&gt; $ Last : chr &quot;Bell&quot; &quot;Seuss&quot; &quot;Student&quot; #&gt; $ Sex : Factor w/ 2 levels &quot;F&quot;,&quot;M&quot;: 1 2 NA #&gt; $ Number: int 2 49 21 Alternatively, you could load the file with strings as factors, and then convert individual columns from factors to characters. 1.4.4 See Also read.csv() is a convenience wrapper function around read.table(). If you need more control over the input, see ?read.table. "],["loading-data-from-an-excel-file.html", "1.5 Loading Data from an Excel File", " 1.5 Loading Data from an Excel File 1.5.1 Problem You want to load data from an Excel file. 1.5.2 Solution The readxl package has the function read_excel() for reading .xls and .xlsx files from Excel. This will read the first sheet of an Excel spreadsheet: # Only need to install once install.packages(&quot;readxl&quot;) library(readxl) data &lt;- read_excel(&quot;datafile.xlsx&quot;, 1) 1.5.3 Discussion With read_excel(), you can load from other sheets by specifying a number for sheetIndex or a name for sheetName: data &lt;- read_excel(&quot;datafile.xls&quot;, sheet = 2) data &lt;- read_excel(&quot;datafile.xls&quot;, sheet = &quot;Revenues&quot;) read_excel() uses the first row of the spreadsheet for column names. If you donâ€™t want to use that row for column names, use col_names = FALSE. The columns will instead be named X1, X2, and so on. By default, read_excel() will infer the type of each column, but if you want to specify the type of each column, you can use the col_types argument. You can also drop columns if you specify the type as \"blank\". # Drop the first column, and specify the types of the next three columns data &lt;- read_excel(&quot;datafile.xls&quot;, col_types = c(&quot;blank&quot;, &quot;text&quot;, &quot;date&quot;, &quot;numeric&quot;)) 1.5.4 See Also See ?read_excel for more options controlling the reading of these files. There are other packages for reading Excel files. The gdata package has a function read.xls() for reading in .xls files, and the xlsx package has a function read.xlsx() for reading in .xlsx files. They require external software to be installed on your computer: read.xls() requires Java, and read.xlsx() requires Perl. "],["loading-data-from-spsssasstata-files.html", "1.6 Loading Data from SPSS/SAS/Stata Files", " 1.6 Loading Data from SPSS/SAS/Stata Files 1.6.1 Problem You want to load data from a SPSS file, or from other programs like SAS or Stata. 1.6.2 Solution The haven package has the function read_sav() for reading SPSS files. To load data from an SPSS file: # Only need to install the first time install.packages(&quot;haven&quot;) library(haven) data &lt;- read_sav(&quot;datafile.sav&quot;) 1.6.3 Discussion The haven package also includes functions to read from other formats: read_sas(): SAS read_dta(): Stata An alternative to haven is the foreign package. It also supports SPSS and Stata files, but it is not as up-to-date as the functions from haven. For example, it only supports Stata files up to version 12, while haven supports up to version 14 (the current version as of this writing). The foreign package does support some other formats, including: read.octave(): Octave and MATLAB read.systat():SYSTAT read.xport(): SAS XPORT read.dta(): Stata read.spss(): SPSS 1.6.4 See Also Run ls(\"package:foreign\") for a full list of functions in the foreign package. "],["CHAPTER-BASIC-CONCEPTS.html", "Chapter 2 Basic Concepts", " Chapter 2 Basic Concepts This chapter covers the basics: installing and using packages and loading data. "],["CHAPTER-THE-AUDIT-SAMPLING-WORKFLOW.html", "Chapter 3 The Audit Sampling Workflow", " Chapter 3 The Audit Sampling Workflow This chapter covers the basics: installing and using packages and loading data. "],["CHAPTER-PLANNING-AUDIT-SAMPLES.html", "Chapter 4 Planning Audit Samples", " Chapter 4 Planning Audit Samples This chapter covers the basics: installing and using packages and loading data. "],["CHAPTER-SELECTING-AUDIT-SAMPLES.html", "Chapter 5 Selecting Audit Samples", " Chapter 5 Selecting Audit Samples This chapter outlines the most commonly used sampling methodology for auditing and shows how to select a sample using these methods with the jfa package. Auditors are often required to assess balances or processes that involve a large number of items. Since they cannot inspect all of these items individually, they need to select a subset (i.e., a sample) from the total population to make a statement about a certain characteristic of the population. For this purpose, various selection methodologies are available that have become standard in an audit context. "],["sampling-units.html", "5.1 Sampling units", " 5.1 Sampling units Selecting a subset from the population requires knowledge of the sampling units; physical representations of the population that needs to be audited. Generally, the auditor has to choose between two types of sampling units: individual items in the population or individual monetary units in the population. In order to perform statistical selection, the population must be divided into individual sampling units that can be assigned a probability to be included in the sample. The total collection of all sampling units which have been assigned a selection probability is called the sampling frame. 5.1.1 Items A sampling unit for record (i.e., attributes) sampling is generally a characteristic of an item in the population. For example, suppose that you inspect a population of receipts. A possible sampling unit for record sampling can be the date of payment of the receipt. When a sampling unit (e.g., date of payment) is selected by the sampling method, the population item that corresponds to the sampled unit is included in the sample. 5.1.2 Monetary units A sampling unit for monetary unit sampling is different than a sampling unit for record sampling in that it is an individual monetary unit within an item or transaction, like an individual dollar. For example, a single sampling unit can be the 10\\(^{th}\\) dollar from a specific receipt in the population. When a sampling unit (e.g., individual dollar) is selected by the sampling method, the population item that includes the sampling unit is included in the sample. "],["sampling-methods.html", "5.2 Sampling methods", " 5.2 Sampling methods This section discusses the four sampling methods implemented in jfa. First, for notation, let the the population \\(N\\) be defined as the total set of individual sampling units \\(x_i\\). \\[N = \\{x_1, x_2, \\dots, x_N\\}.\\] In statistical sampling, every sampling unit \\(x_i\\) in the population must receive a selection probability \\(p(x_i)\\). The purpose of the sampling method is to provide a framework to assign selection probabilities to each of the sampling units, and subsequently draw sampling units from the population until a set of size \\(n\\) has been created. The next section discusses which sampling methods are available in jfa. To illustrate the outcomes for different sampling methods, we will use the BuildIt data set that can be loaded using the code below. data(BuildIt) 5.2.1 Fixed interval sampling (Systematic sampling) Fixed interval sampling is a method designed for yielding representative samples from monetary populations. The algorithm determines a uniform interval on the (optionally ranked) sampling units. Next, a starting point is handpicked or randomly selected in the first interval and a sampling unit is selected throughout the population at each of the uniform intervals from the starting point. For example, if the interval has a width of 10 sampling units and sampling unit number 5 is chosen as the starting point, the sampling units 5, 15, 25, etc. are selected to be included in the sample. The number of required intervals \\(I\\) can be determined by dividing the number of sampling units in the population by the required sample size: \\[I = \\frac{N}{n},\\] in which \\(n\\) is the required sample size and \\(N\\) is the total number of sampling units in the population. If the space between the selected sampling units is equal, the selection probability for each sampling unit is theoretically defined as: \\[p(x) = \\frac{1}{I},\\] with the property that the space between selected units \\(i\\) is the same as the interval \\(I\\), see Figure 1. However, in practice the selection is deterministic and completely depends on the chosen starting points (using start). Figure 1: Illustration of fixed interval sampling The fixed interval method yields a sample that allows every sampling unit in the population an equal chance of being selected. However, the fixed interval method has the property that all items in the population with a monetary value larger than the interval \\(I\\) have an selection probability of one because one of these itemsâ€™ sampling units are always selected from the interval. Note that, if the population is arranged randomly with respect to its deviation pattern, fixed interval sampling is equivalent to random selection. Advantage(s): The advantage of the fixed interval sampling method is that it is often simple to understand and fast to perform. Another advantage is that, in monetary unit sampling, all items that are greater than the calculated interval will be included in the sample. In record sampling, since units can be ranked on the basis of value, there is also a guarantee that some large items will be in the sample. Disadvantage(s): A pattern in the population can coincide with the selected interval, rendering the sample less representative. What is sometimes seen as an added complication for this method is that the sample is hard to extend after drawing the initial sample. This is due to the chance of selecting the same sampling unit. However, by removing the already selected sampling units from the population and redrawing the intervals this problem can be efficiently solved. As an example, the code below shows how to apply the fixed interval sampling method in a record sampling and a monetary unit sampling setting. Note that, by default, the first sampling unit from each interval is selected. However, this can be changed by setting the argument start = 1 to a different value. # Record sampling sample &lt;- selection(data = BuildIt, size = 100, units = &quot;items&quot;, method = &quot;interval&quot;, start = 1) #head(sample$sample, n = 6) # Monetary unit sampling sample &lt;- selection(data = BuildIt, size = 100, units = &quot;values&quot;, method = &quot;interval&quot;, values = &quot;bookValue&quot;, start = 1) #head(sample$sample, n = 6) 5.2.2 Cell sampling The cell sampling method divides the (optionally ranked) population into a set of intervals \\(I\\) that are computed through the previously given equations. Within each interval, a sampling unit is selected by randomly drawing a number between 1 and the interval range \\(I\\). This causes the space \\(i\\) between the sampling units to vary. Like in the fixed interval sampling method, the selection probability for each sampling unit is defined as: \\[p(x) = \\frac{1}{I}.\\] Figure 2: Illustration of cell sampling The cell sampling method has the property that all items in the population with a monetary value larger than twice the interval \\(I\\) have a selection probability of one. Advantage(s): More sets of samples are possible than in fixed interval sampling, as there is no systematic interval \\(i\\) to determine the selections. It is argued that the cell sampling algorithm offers a solution to the pattern problem in fixed interval sampling. Disadvantage(s): A disadvantage of this sampling method is that not all items in the population with a monetary value larger than the interval have a selection probability of one. Besides, population items can be in two adjacent cells, thereby creating the possibility that an items is included in the sample twice. As an example, the code below shows how to apply the cell sampling method in a record sampling and a monetary unit sampling setting. It is important to set a seed to make the results reproducible. # Record sampling set.seed(1) sample &lt;- selection(data = BuildIt, size = 100, units = &quot;items&quot;, method = &quot;cell&quot;) #head(sample$sample, n = 6) # Monetary unit sampling set.seed(1) sample &lt;- selection(data = BuildIt, size = 100, units = &quot;values&quot;, method = &quot;cell&quot;, values = &quot;bookValue&quot;) #head(sample$sample, n = 6) 5.2.3 Random sampling Random sampling is the most simple and straight-forward selection method The random sampling method provides a method that allows every sampling unit in the population an equal chance of being selected, meaning that every combination of sampling units has the same probability of being selected as every other combination of the same number of sampling units. Simply put, the algorithm draws a random selection of size \\(n\\) of the sampling units. Therefore, the selection probability for each sampling unit is defined as: \\[p(x) = \\frac{1}{N},\\] where \\(N\\) is the number of units in the population. To clarify this procedure, Figure 3 provides an illustration of the random sampling method. Figure 3: Illustration of random sampling Advantage(s): The random sampling method yields an optimal random selection, with the additional advantage that the sample can be easily extended by applying the same method again. Disadvantages: Because the selection probabilities are equal for all sampling units there is no guarantee that items with a large monetary value in the population will be included in the sample. As an example, the code below shows how to apply the random sampling (with our without replacement using replace) method in a record sampling and a monetary unit sampling setting. It is important to set a seed to make results reproducible. # Record sampling set.seed(1) sample &lt;- selection(data = BuildIt, size = 100, units = &quot;items&quot;, method = &quot;random&quot;) #head(sample$sample, n = 6) # Monetary unit sampling set.seed(1) sample &lt;- selection(data = BuildIt, size = 100, units = &quot;values&quot;, method = &quot;random&quot;, values = &quot;bookValue&quot;) #head(sample$sample, n = 6) 5.2.4 Modified Sieve Sampling The fourth option for the sampling method is modified sieve sampling (Hoogduin, Hall, &amp; Tsay, 2010). The algorithm starts by selecting a standard uniform random number \\(R_i\\) between 0 and 1 for each item in the population. Next, the sieve ratio: \\[S_i = \\frac{Y_i}{R_i}\\] is computed for each item by dividing the book value of that item by the random number. Lastly, the items in the population are sorted by their sieve ratio \\(S\\) (in decreasing order) and the top \\(n\\) items are selected for inspection. In contrast to the classical sieve sampling method (Rietveld, 1978), the modified sieve sampling method provides precise control over sample sizes. As an example, the code below shows how to apply the modified sieve sampling method in a monetary unit sampling setting. It is important to set a seed to make results reproducible. # Monetary unit sampling set.seed(1) sample &lt;- selection(data = BuildIt, size = 100, units = &quot;values&quot;, method = &quot;sieve&quot;, values = &quot;bookValue&quot;) #head(sample$sample, n = 6) "],["ordering-or-randomizing-the-population.html", "5.3 Ordering or randomizing the population", " 5.3 Ordering or randomizing the population The selection() function has additional arguments (order, decreasing, and randomize) to preprocess your population before selection. The order argument takes as input a column name in data which determines the order of the population. For example, you can order the population from lowest book value to highest book value before engaging in selection. In this case, you should use the decreasing = FALSE argument. # Ordering population from lowest &#39;bookValue&#39; to highest &#39;bookValue&#39; before MUS set.seed(1) sample &lt;- selection( data = BuildIt, size = 100, units = &quot;values&quot;, values = &quot;bookValue&quot;, order = &quot;bookValue&quot;, decreasing = FALSE ) #head(sample$sample, n = 6) The randomize argument can be used to randomly shuffle the items in the population before selection. # Randomly shuffle population items before MUS set.seed(1) sample &lt;- selection( data = BuildIt, size = 100, units = &quot;values&quot;, values = &quot;bookValue&quot;, randomize = TRUE ) #head(sample$sample, n = 6) "],["references.html", "5.4 References", " 5.4 References Hoogduin, L. A., Hall, T. W., &amp; Tsay, J. J. (2010). Modified sieve sampling: A method for single-and multi-stage probability-proportional-to-size sampling. Auditing: A Journal of Practice &amp; Theory, 29(1), 125-148. Leslie, D. A., Teitlebaum, A. D., &amp; Anderson, R. J. (1979). Dollar-unit Sampling: A Practical Guide for Auditors. London: Pitman. "],["CHAPTER-UNSTRATIFIED-EVALUATION-OF-AUDIT-SAMPLES.html", "Chapter 6 Unstratified Evaluation of Audit Samples", " Chapter 6 Unstratified Evaluation of Audit Samples This chapter covers the basics: installing and using packages and loading data. "],["CHAPTER-STRATIFIED-EVALUATION-OF-AUDIT-SAMPLES.html", "Chapter 7 Stratified Evaluation of Audit Samples", " Chapter 7 Stratified Evaluation of Audit Samples This chapter covers the basics: installing and using packages and loading data. "],["CHAPTER-OTHER-SOFTWARE-IMPLEMENTATTIONS.html", "Chapter 8 Other Software Implementations", " Chapter 8 Other Software Implementations This chapter covers the basics: installing and using packages and loading data. "],["references-1.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
